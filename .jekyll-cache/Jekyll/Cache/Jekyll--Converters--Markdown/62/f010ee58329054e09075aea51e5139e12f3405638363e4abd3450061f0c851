I"è<h1 id="mqtt-protocol">MQTT Protocol</h1>
<ul>
  <li>MQTT = Message Queuing Telemetry Transport
  Telemetry = Tele-Metering = Remote Measurements</li>
  <li>Originally Developed by IBM, now Open Sourced.</li>
  <li>Though MQ stands for ‚ÄòMessage Queuing‚Äô, actually there‚Äôs NO Messages being Queued.</li>
  <li>It‚Äôs a <strong><em><u>Publish/Subscribe</u></em></strong> mechanism.
    <ul>
      <li>Sensor Devices Publish data to the Topics/Servers/Brokers.</li>
      <li>Topics are subscribed by other devices such as mobile devices those are looking for data from Sensors.</li>
    </ul>
  </li>
  <li><em><u>Low Bandwidth Protocol</u></em>
    <ul>
      <li>Messages being sent by devices are very small in bytes.</li>
      <li>e.g. Temperature sensor sending 100 degree reading.</li>
    </ul>
  </li>
  <li>Small Code Footprint
    <ul>
      <li>The code used for this is very small.</li>
    </ul>
  </li>
  <li>Used in:
    <ul>
      <li>Facebook Messenger for iOS and Android</li>
      <li>PubNub</li>
    </ul>
  </li>
</ul>

<h2 id="mqtt-ports">MQTT Ports</h2>
<ul>
  <li>Protocol: TCP/IP</li>
  <li>Ports:
    <ul>
      <li>1883 - non-encrypted communication</li>
      <li>8883 - encrypted communication</li>
    </ul>
  </li>
</ul>

<h2 id="maximum-payload-size">Maximum Payload Size</h2>
<ul>
  <li>MQTT Protocol Max Payload - 256 MBs</li>
  <li>AWS IoT MQTT Max Payload - 128 KBs</li>
</ul>

<h2 id="quality-of-service">Quality of Service</h2>
<ul>
  <li>Levels:<br />
    0 = <em><u>At Most Once</u></em> (Best effort, No Ack)<br />
      - Sender does not store messages, neither the receiver sends any acknowledgement.
    1 = <em><u>At Least Once</u></em> (Acknowledged, Retransmitted if Ack not received)<br />
    2 = <em><u>Exactly Once</u></em>\</li>
  <li>4 Messages exchanged:
    <ul>
      <li>Request to Send (Publish)</li>
      <li>Clear to Send (Pubrec)</li>
      <li>Message (Pubrel)</li>
      <li>Ack (Pubcomp)</li>
    </ul>
  </li>
  <li>these messages are same as used in WiFi communication.</li>
</ul>

<h2 id="retained-messages">Retained Messages</h2>
<ul>
  <li>Server keeps messages even after sending it to all Subscribers.</li>
  <li>New Subscribers get the retained messages.
    <ul>
      <li>We had seen this behavior in PubNub, where last message Published to Channel was retained till the next message is Published to that channel.</li>
      <li>This Last message was available to new subscriber.</li>
      <li><em><u>Only One Message</u></em> is retained per Topic.</li>
      <li>Usecase:
        <ul>
          <li>Sensor periodically sending a message on a topic. New subscriber will get the last state of the sensor with Retained message.</li>
        </ul>
      </li>
      <li>Reference: <a href="/assets/docs/mqtt/MQTT_Retained_Messages_Explained.pdf">MQTT Retained Messages Explained</a></li>
    </ul>
  </li>
</ul>

<h2 id="clean-session-and-durable-session">Clean Session and Durable Session</h2>
<ul>
  <li><em><u>Clean Session</u></em>:
    <ul>
      <li>Clean Session Flag = 1	[Optional]</li>
      <li>All of the client‚Äôs subscriptions are removed when it disconnects from the server.</li>
    </ul>
  </li>
  <li><em><u>Durable Session</u></em>:
    <ul>
      <li>Clean Session Flag = 0	[Optional]</li>
      <li>The client‚Äôs subscriptions remain in effect after any disconnection.</li>
      <li>In this event, subsequent messages that arrive carrying a High QoS designation are stored for delivery after the connection is reestablished.</li>
    </ul>
  </li>
</ul>

<h2 id="retained-messages-clean-session-and-qos-inter-related-behavior">Retained messages, Clean Session and QoS inter-related behavior</h2>
<p><img src="/assets/images/mqtt/RetainedMessages_CleanSession_QoS.png" alt="Retained messages, Clean Session and QoS inter-related behavior" />
  Reference: <a href="http://www.steves-internet-guide.com/mqtt-retained-messages-example/">MQTT Retained Messages Explained</a></p>

<h2 id="wills">Wills</h2>
<ul>
  <li>A Will or a Message is informed by client with server that should be published to a specific Topic or Topics in the event of an unexpected disconnection.</li>
  <li>A Will is an alarm or security settings where system when a remote sensor has lost contact with the network.</li>
</ul>

<h2 id="keep-alive-messages">Keep Alive Messages</h2>
<ul>
  <li>Periodically sent</li>
</ul>

<h2 id="topic-trees-strings">Topic Trees, Strings</h2>
<ul>
  <li>Topics are organized Hierarchically into Topic Trees, using the ‚Äò/‚Äô character to create subtopics in the Topic String.</li>
  <li><em><u>Topic String</u></em>
    <ul>
      <li>A character string that identifies the Topic of a publish/subscribe message.</li>
      <li>Topic strings can contain either of two Wildcards:</li>
      <li>These <strong><em><u>WildCards</u></em></strong> Allows subscribers to match patterns within strings defined by message publishers</li>
      <li>Wildcard: <code class="language-plaintext highlighter-rouge">#</code>:
        <ul>
          <li>Multilevel</li>
          <li>used to match any number of levels within a Topic.
            <ul>
              <li>e.g. subscribers to <code class="language-plaintext highlighter-rouge">truck/contents/#</code> receive all messages that are designated for the topics:</li>
              <li><code class="language-plaintext highlighter-rouge">truck/contents</code></li>
              <li><code class="language-plaintext highlighter-rouge">truck/contents/rfid</code></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Wildcard: <code class="language-plaintext highlighter-rouge">+</code>:
        <ul>
          <li>Single Level</li>
          <li>used to match Just ONE Topic Level.
            <ul>
              <li>e.g. <code class="language-plaintext highlighter-rouge">truck/+</code> <u>matches</u> <code class="language-plaintext highlighter-rouge">truck/contents</code> <em><u>but not</u></em> <code class="language-plaintext highlighter-rouge">truck/contents/rfid</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="mqtt-brokers-comparison">MQTT Brokers Comparison</h2>
<ul>
  <li><a href="/assets/docs/mqtt/Stress-Testing-MQTT-Brokers.pdf">Stress-Testing MQTT Brokers: A Comparative Analysis of Performance Measurements:</a>
    <ul>
      <li>Tested Borkers:
        <ul>
          <li><a href="https://mosquitto.org/"><em><u>Mosquitto</u></em></a> - <a href="https://www.bevywise.com/mqtt-broker/"><em><u>Bevywise MQTT Route</u></em></a> - <a href="https://activemq.apache.org/"><em><u>ActiveMQ</u></em></a> - <a href="https://www.hivemq.com/"><em><u>HiveMQ CE</u></em></a> - <a href="https://vernemq.com/"><em><u>VerneMQ</u></em></a> - <a href="https://www.emqx.io/"><em><u>EMQ X</u></em></a></li>
        </ul>
      </li>
      <li><strong><em><u>Mosquitto</u></em></strong> outperforms the other considered solutions in most metrics;</li>
      <li><strong><em><u>ActiveMQ</u></em></strong> is the best performing one in terms of <em><u>Scalability</u></em> due to its multi-threaded implementation.</li>
      <li><strong><em><u>Bevywise MQTT Route</u></em></strong> has promising results for <em><u>resource-constrained</u></em> scenarios.</li>
      <li><strong><em><u>ActiveMQ</u></em></strong> scales well in distributed/multi-core environment to beat all other brokers‚Äô performance.</li>
      <li>If the hardware is <em><u>resource-constrained</u></em> (CPU/Memory/IO/Performance), then <strong><em><u>Mosquitto</u></em></strong> or <strong><em><u>Bevywise MQTT Route</u></em></strong> can be taken as better choices.</li>
    </ul>
  </li>
</ul>

<h2 id="running-mqtt-broker-in-containerized-mode">Running MQTT broker in Containerized mode</h2>
<ul>
  <li><a href="https://hub.docker.com/_/eclipse-mosquitto?tab=description">eclipse-mosquitto</a>
    <ul>
      <li>Maintained by: the Eclipse Foundation</li>
      <li>Supported architectures: (more info) amd64, arm32v6, arm64v8, i386, ppc64le, s390x</li>
    </ul>
  </li>
</ul>

:ET