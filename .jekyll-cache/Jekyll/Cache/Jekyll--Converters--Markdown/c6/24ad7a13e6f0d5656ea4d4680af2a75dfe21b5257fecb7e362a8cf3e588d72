I"ÚM<p>This write-up will explain different <strong><em><u>Sequence containers</u></em></strong>, their respective features and mainly their appropriate use-cases.</p>

<h2 id="array">Array</h2>
<ul>
  <li>(C++11)	(Sequence)</li>
  <li>Features:
    <ul>
      <li>Contiguous memory - allows <em><u>Constant time</u></em> <strong>Random access</strong> to elements.</li>
      <li>Strict <strong>Ordered</strong> <em><u>Linear</u></em> Sequence.</li>
      <li><em><u>Fixed-size</u></em> Sequence container: they hold a specific number of elements ordered in a strict linear sequence.
The container uses Implicit Constructors and Destructors to <em><u>allocate</u></em> the required space <em><u>Statically</u></em>.</li>
      <li>Its size is *<u>Compile-time constant</u>.</li>
      <li>No memory or time overhead.</li>
      <li>This Array class merely adds a layer of member and global functions to it, so that arrays can be used as standard containers.</li>
      <li>cannot be expanded or contracted dynamically.</li>
      <li>Zero-sized arrays are valid, but they should not be dereferenced.</li>
      <li>Swapping two array containers is a Linear and considerably less efficient operation, as it involves swapping of all members individually.</li>
      <li>Another unique feature of array containers is that they can be treated as â€˜tupleâ€™(C++11) objects.</li>
    </ul>
  </li>
</ul>

<h3 id="advantages-over-traditional-cc-arrays">Advantages over traditional C/C++ Arrays</h3>
<ul>
  <li><strong>std::array</strong> classes knows its own Size, whereas C-style arrays lack this property.
    <ul>
      <li>So when passing to functions, we <em><u>donâ€™t need to pass Size of Array as a separate parameter</u></em>.</li>
    </ul>
  </li>
  <li>With <em><u>C-style array there is more risk of array being Decayed into a pointer</u></em>.
    <ul>
      <li>std::array classes donâ€™t decay into pointers.</li>
      <li>See: Array_Decay_Avoiding.cpp</li>
    </ul>
  </li>
  <li>std::array classes are generally more efficient, light-weight and reliable than C-style arrays.</li>
  <li>Arrays are Fixed-Size Sequence Containers:
    <ul>
      <li>they hold a specific number of elements Ordered in a strict Linear Sequence.</li>
    </ul>
  </li>
  <li>std::array class internally DOES NOT contain any Data other than Elements it hold.(not even its Size)
    <ul>
      <li>std::array class merely adds a layer of member and global functions to it, so that arrays can be used as standard containers.</li>
    </ul>
  </li>
  <li>Unlike the other standard containers, Arrays have a <strong>Fixed Size</strong> and they CANNOT be expanded or contracted dynamically.</li>
  <li>Zero-sized arrays are valid, but they should not be dereferenced.</li>
  <li>Unlike with the other containers in the Standard Library, Swapping two array containers is a Linear Operation that involves Swapping All the Elements in the ranges Individually, which generally is a considerably Less Efficient operation. On the other side, this allows the iterators to elements in both containers to keep their original container association.
    <ul>
      <li>Another unique feature of std::array containers is that they can be treated as <strong>tuple</strong> objects:</li>
      <li>The <strong>std::array</strong> header overloads the <strong>get&lt;&gt;</strong> function to access the elements of the array as if it was a tuple, as well as specialized <strong>tuple_size</strong> and <strong>tuple_element</strong> types.</li>
    </ul>
  </li>
</ul>

<h5 id="references">References:</h5>
<ul>
  <li><a href="https://www.cplusplus.com/reference/array/array/">std::array</a></li>
  <li><a href="https://www.geeksforgeeks.org/what-is-array-decay-in-c-how-can-it-be-prevented/">What is Array Decay in C++? How can it be prevented?</a></li>
</ul>

<h2 id="deque">Deque</h2>
<ul>
  <li>Double-Ended queue</li>
  <li><strong>Sequence Container</strong> - Ordered in a strict Linear Sequence</li>
  <li><strong>Dynamic Size</strong>: Expanded/Contracted on both ends(front/back)</li>
  <li><strong>Random Access</strong> Iterators - <em><u>Access to individual elements</u></em> - in <em><u>Constant Time</u></em></li>
  <li>similar to <em><u>vectors</u></em>, but with efficient insertion/deletion of elements not only at the end, but at front/mid-positions also.</li>
  <li><strong>DOES NOT</strong> guaranteed to store all its elements in <em><u>Contiguous Storage</u></em> locations:
    <ul>
      <li>elements of <code class="language-plaintext highlighter-rouge">deque</code> can be scattered in different chunks of storage, container keeps track of it for Random access.\</li>
      <li>:x: <u>Accessing elements in a deque</u> by <em><u>offsetting a pointer</u></em> to another element causes <em><u>undefined behavior</u></em>.</li>
      <li>:x: DO NOT access elements with pointer+offset.</li>
    </ul>
  </li>
  <li>deques perform worse for operations that involve frequent insertion/deletion of elements at positions other than the beginning or the end
    <ul>
      <li>:x: i.e. deque should NOT be used for insertion/deletion at mid-positions.</li>
    </ul>
  </li>
</ul>

<h3 id="vector-vs-deque">vector vs deque:</h3>
<ul>
  <li>Both vectors and deques provide a very similar interface and can be used for similar purposes, but internally both work in quite different ways:
    <ul>
      <li><em><u>vectors</u></em> - use a <u>contiguous storage locations<u> that needs to be occasionally reallocated for growth,</u></u></li>
      <li><em><u>deque</u></em> - <u>Elements can be scattered in different chunks of storage</u>, with the container keeping the necessary information internally to provide direct access to any of its elements in constant time and with a uniform sequential interface (through iterators).</li>
    </ul>
  </li>
  <li>Therefore, <em><u>deques</u></em> are a little more complex internally than vectors, but this <em><u>allows them to grow more efficiently</u></em> under certain circumstances, especially with very long sequences, where reallocations become more expensive.</li>
  <li><em><u>deques</u></em> are efficient with <u>insertion and deletion</u> of elements also <em><u>at the beginning &amp; end</u></em> of the sequence.</li>
  <li><em><u>vectors</u></em> are efficient with <u>insertion and deletion</u> of elements <strong>ONLY</strong> <em><u>at the end</u></em> of the sequence.</li>
</ul>

<h3 id="deque-decision-criteria">Deque Decision Criteria</h3>
<ul>
  <li>:heavy_check_mark:  Size varies widely - <strong>Dynamic</strong></li>
  <li>:heavy_check_mark:  Need to find Nth element - <strong>Random Access</strong></li>
  <li>:heavy_check_mark:  <strong>Insert/Erase</strong> at the <em><u>Front/Back</u></em></li>
  <li>:x: <strong>Insert/Erase</strong> at <em><u>Mid-positions</u></em></li>
  <li>:x: <strong>Key:Value</strong> pair</li>
  <li>:x: <strong>Order</strong> is Important</li>
</ul>

<h5 id="references-1">References</h5>
<ul>
  <li><a href="https://www.geeksforgeeks.org/deque-cpp-stl/">Deque in C++ Standard Template Library (STL)</a></li>
  <li><a href="https://www.cplusplus.com/reference/deque/deque/">std::deque</a></li>
</ul>

<h2 id="vector">Vector</h2>
<ul>
  <li><strong>Sequence</strong></li>
  <li><strong>Ordered</strong></li>
  <li><strong>Random Access</strong></li>
  <li><strong>Insert/Erase</strong> <em><u>at the End</u></em></li>
  <li>Features:
    <ul>
      <li>A vector is a <strong>Sequence</strong>
        <ul>
          <li>Sequence Container - Ordered in a strict Linear Sequence</li>
        </ul>
      </li>
      <li><strong>Random Access</strong> to elements - in <em><u>Constant time</u></em></li>
      <li><em><u>Contiguous Memory</u></em>.
        <ul>
          <li>which means that their elements can also be accessed using offsets on regular pointers to its elements.</li>
        </ul>
      </li>
      <li><strong>Insertion/Deletion</strong>:
        <ul>
          <li><em><u>Constant time</u></em> - <strong>AT the END</strong></li>
          <li><em><u>Linear time</u></em> - <strong>at the beginning/mid-positions</strong></li>
        </ul>
      </li>
      <li><strong>Dynamic Size</strong> - An Advantage over Arrays. - Arrays that can <em><u>change Size</u></em>.</li>
      <li><strong>Reallocation</strong>:
        <ul>
          <li>vectors internally use dynamically allocated arrays</li>
          <li>:warning: To modify size dynamically, arrays needs to reallocated, and all elements needs to be moved, this is a <em><u>less efficient</u></em>, <em><u>costly operation</u></em> to perform frequently.</li>
          <li>so, vectors allocate some extra memory for accommodation.</li>
          <li>so, <em><u>actual 'capacity' of vectors is greater than 'size' of vectors</u></em>.</li>
          <li>Vectors consume more memory than Arrays, due to above reasons.</li>
          <li>When it is necessary to <em><u>increase capacity()</u></em>, vector usually <em><u>increases it by</u></em> a <strong>factor of two</strong>.</li>
          <li>:warning: Reallocation INVALIDATES any iterators that point into the vector.</li>
          <li><em><u>reserve()</u></em> causes a reallocation manually.
            <ul>
              <li>The main reason for using reserve() is <u>efficiency</u>.</li>
              <li>using reserve(), you can control the INVALIDATION of iterators.</li>
            </ul>
          </li>
          <li>:warning: Inserting or Deleting an element <em><u>in the middle</u></em> of a vector INVALIDATES all iterators.</li>
          <li>:heavy_check_mark: Insertion/Deletion <em><u>at the end</u></em> of the vector, prevents vector iterators from being invalidated.
            <ul>
              <li>i.e. vectors are designed to be expanded at â€˜ENDâ€™</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Vectors more efficient in accessing Random elements, than â€˜dequeâ€™/â€™listsâ€™/â€™forward_listsâ€™</li>
    </ul>
  </li>
</ul>

<h3 id="time-complexity-vector-operations">Time Complexity Vector Operations</h3>

<table>
  <thead>
    <tr>
      <th>Operation</th>
      <th style="text-align: center">Time Complexity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Insert at Head</td>
      <td style="text-align: center"><strong><em>O(n)</em></strong></td>
    </tr>
    <tr>
      <td>Insert at Index</td>
      <td style="text-align: center"><strong><em>O(n)</em></strong></td>
    </tr>
    <tr>
      <td>Insert at Tail</td>
      <td style="text-align: center"><strong><em>O(1)</em></strong></td>
    </tr>
    <tr>
      <td>Remove at Head</td>
      <td style="text-align: center"><strong><em>O(n)</em></strong></td>
    </tr>
    <tr>
      <td>Remove at Index</td>
      <td style="text-align: center"><strong><em>O(n)</em></strong></td>
    </tr>
    <tr>
      <td>Remove at Tail</td>
      <td style="text-align: center"><strong><em>O(1)</em></strong></td>
    </tr>
    <tr>
      <td>Find Index</td>
      <td style="text-align: center"><strong><em>O(1)</em></strong></td>
    </tr>
    <tr>
      <td>Find/Search Object</td>
      <td style="text-align: center"><strong><em>O(n)</em></strong></td>
    </tr>
  </tbody>
</table>

<h3 id="vector-decision-criteria">Vector Decision Criteria</h3>
<ul>
  <li>:heavy_check_mark: Insert/Erase at the End</li>
  <li>:heavy_check_mark: when Nth element is to be found - Random Access</li>
  <li>:x: when Order is important</li>
  <li>:x: Key:Value pair required</li>
  <li>:x: When thereâ€™s need of Insert/Erase in Middle/Front, as it invalidates iterators.</li>
  <li>:x: when Size will vary widely, as it causes Reallocation, which in turn invalidates iterators.</li>
</ul>

<h5 id="references-2">References</h5>
<ul>
  <li><a href="https://www.cplusplus.com/reference/vector/vector/">std::vector</a></li>
</ul>

<h2 id="lists">Lists</h2>
<ul>
  <li><strong>Sequence</strong></li>
  <li><strong>Insert/Erase at the Front/Back/Mid</strong></li>
  <li><strong>NO Random Access</strong></li>
  <li><strong>Iterate =&gt; Forward/Backward</strong></li>
  <li>Features:
    <ul>
      <li>Sequence container</li>
      <li>Doubly Linked List.	â€“ Bidirectional Iterators.</li>
      <li>Iterate/Traverse in Both Forward/Backward.</li>
      <li><strong>Insertion/Deletion</strong>:
        <ul>
          <li>:heavy_check_mark: <em><u>Constant time</u></em> - <strong>at the Beginning/End/Mid-position</strong> i.e. ANYWHERE.
            <ul>
              <li>i.e. We can 8<u>insert(iterator pos, const T&amp; x)</u>* at a specific position</li>
              <li>and <em><u>erase(iterator pos)</u></em> at the specific position.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>:heavy_check_mark: Lists have the important property that <em><u>Insertion</u></em> and <em><u>Splicing</u></em> <strong>DO NOT invalidate iterators</strong> to list elements
        <ul>
          <li>i.e. same iterators can be used, they get themselves aligned to updated list.</li>
        </ul>
      </li>
      <li>:x: <em><u>Memory</u></em> allocation is <strong>NOT Contagious</strong>.</li>
      <li><strong><em><u>forward_list</u></em></strong> performs better than <em><u>arrays/vectors/deque</u></em> in actions as <em><u>Inserting/Deleting/Extracting/Moving</u></em> elements within the container.</li>
      <li>:x: <strong><em><u>forward_list</u></em></strong> and <strong><em><u>list</u></em></strong> <em><u>Do NOT</u></em> have Direct/<strong>Random Access</strong> to elements.
        <ul>
          <li>Forward_list &amp; List has to Iterate element by element to desired element.</li>
          <li>i.e. <em><u>Linear Time</u></em></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="time-complexity-list-operations">Time Complexity List Operations</h3>

<table>
  <thead>
    <tr>
      <th>Operation</th>
      <th style="text-align: center">Time Complexity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Insert at Head</td>
      <td style="text-align: center"><strong><em>O(1)</em></strong></td>
    </tr>
    <tr>
      <td>Insert at Index</td>
      <td style="text-align: center"><strong><em>O(n)</em></strong></td>
    </tr>
    <tr>
      <td>Insert at Tail</td>
      <td style="text-align: center"><strong><em>O(1)</em></strong></td>
    </tr>
    <tr>
      <td>Remove at Head</td>
      <td style="text-align: center"><strong><em>O(1)</em></strong></td>
    </tr>
    <tr>
      <td>Remove at Index</td>
      <td style="text-align: center"><strong><em>O(n)</em></strong></td>
    </tr>
    <tr>
      <td>Remove at Tail</td>
      <td style="text-align: center"><strong><em>O(1)</em></strong></td>
    </tr>
    <tr>
      <td>Find Index</td>
      <td style="text-align: center"><strong><em>O(1)</em></strong></td>
    </tr>
    <tr>
      <td>Find/Search Object</td>
      <td style="text-align: center"><strong><em>O(n)</em></strong></td>
    </tr>
  </tbody>
</table>

<h3 id="list-decision-criteria">List Decision Criteria</h3>
<ul>
  <li>:heavy_check_mark: If Insert/Erase is required in middle/front/end i.e. ANYWHERE.</li>
  <li>:heavy_check_mark: Forward and Backward Traversal is required.</li>
  <li>:heavy_check_mark: If required to merge collections.					â€“&gt; Study more.</li>
  <li>:x: Random Access is required.</li>
  <li>:x: If Order is important.</li>
  <li>:x: Key:Value pair required.</li>
</ul>

<h5 id="reference">Reference</h5>
<ul>
  <li><a href="https://www.cplusplus.com/reference/list/list/">std::list</a></li>
</ul>

<h2 id="forward-list">Forward List</h2>
<ul>
  <li><strong>Sequence</strong> - <em><u>Singly Linked List</u></em></li>
  <li><strong>Iterate</strong> =&gt; Forward</li>
  <li><strong>Insert/Erase</strong> =&gt; Front/Back/Mid</li>
  <li>Features:
    <ul>
      <li>Singly Linked List: a list where each element is linked to the next element, but not to the previous element.
â€“ Forward Iterators
        <ul>
          <li>Singly Linked Lists are smaller and <em><u>faster</u></em> than double linked lists.</li>
          <li>It is a Sequence that supports forward but not backward traversal.</li>
        </ul>
      </li>
      <li><strong>Insertion/Deletion</strong>
        <ul>
          <li><em><u>Constant time</u></em> - at the <strong>Beginning</strong> or the <strong>End</strong>, or in the <strong>Middle</strong>.
            <ul>
              <li>i.e. We can <em><u>insert/insert_after(iterator pos, const T&amp; x)</u></em> at a specific position</li>
              <li>and <em><u>erase/erase_after(iterator pos)</u></em> at the specific position.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>like <strong>std::list</strong>, <strong>std::forward_list</strong> also has the important property that Insertion and Splicing <strong>DO NOT</strong> <em><u>Invalidate</u></em> iterators to list elements.
        <ul>
          <li>i.e. same iterators can be used, they get themselves alligned to updated list.</li>
        </ul>
      </li>
      <li>This is the only container, that <strong>DO NOT</strong> have <em><u>size()</u></em> member function, because:
        <ul>
          <li>for efficiency considerations:</li>
          <li>Being a Linked List, for having a size() member that takes constant time would require it to keep an internal counter for its size (as std::list does).</li>
          <li>This would consume some extra storage and make insertion and removal operations slightly less efficient.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="important-functionality-difference-between-stdlist--stdforward_list">Important Functionality Difference between std::list &amp; std::forward_list:</h3>
<ul>
  <li><em><u>insert()</u></em> &amp; <em><u>erase()</u></em>:
    <ul>
      <li>Using these member functions carelessly, can result in disastrously slow programs.</li>
      <li>The problem is that insert() inserts the new element(s) before pos.</li>
      <li>This means that insert must find the iterator just before pos; this is a constant-time operation for std::list, since it is bidirectional.</li>
      <li>but for std::forward_list it must find that iterator by traversing the list from the beginning up to pos.</li>
      <li>In other words: <em>insert()</em> and <em>erase()</em> are <em><u>slow operations anywhere but near the beginning</u></em> of the std::forward_list.</li>
    </ul>
  </li>
  <li><em><u>insert_after()</u></em> &amp; <em><u>erase_after()</u></em>:
    <ul>
      <li>insert_after() and erase_after() are <em><u>constant time</u></em> operations:
        <ul>
          <li>you should always use insert_after() and erase_after() whenever possible.</li>
          <li>If you find that insert_after() and erase_after() arenâ€™t adequate for your needs, and that you often need to use insert() and erase() in the middle of the list, then you should probably use std::list instead of std::forward_list.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>std::forward_list is <strong>more efficient</strong> than std::list
    <ul>
      <li>As std::list consumes additional storage per element</li>
      <li>std::list has with a slight higher time overhead inserting and removing elements, as it has to fill both the pointers correctly.</li>
    </ul>
  </li>
</ul>

<h3 id="forward-list-decision-criteria">Forward List Decision Criteria</h3>
<ul>
  <li>:heavy_check_mark: If Insert/Erase is required in middle/front/end i.e. ANYWHERE.</li>
  <li>:heavy_check_mark: If required to merge collections.					â€“&gt; Study more.</li>
  <li>:x: Backward Traversal is required.</li>
  <li>:x: Random Access is required.</li>
  <li>:x: If Order is important.</li>
  <li>:x: Key:Value pair required.</li>
</ul>

<h5 id="reference-1">Reference</h5>
<ul>
  <li><a href="https://www.cplusplus.com/reference/forward_list/forward_list/">std::forward_list</a></li>
</ul>

:ET