I" *<h1 id="mqtt-protocol">MQTT Protocol</h1>
<ul>
  <li>MQTT = Message Queuing Telemetry Transport
  Telemetry = Tele-Metering = Remote Measurements</li>
  <li>Originally Developed by IBM, now Open Sourced.</li>
  <li>Though MQ stands for ‘Message Queuing’, actually there’s NO Messages being Queued.</li>
  <li>It’s a <strong><em><u>Publish/Subscribe</u></em></strong> mechanism.
    <ul>
      <li>Sensor Devices Publish data to the Topics/Servers/Brokers.</li>
      <li>Topics are subscribed by other devices such as mobile devices those are looking for data from Sensors.</li>
    </ul>
  </li>
  <li><em><u>Low Bandwidth Protocol</u></em>
    <ul>
      <li>Messages being sent by devices are very small in bytes.</li>
      <li>e.g. Temperature sensor sending 100 degree reading.</li>
    </ul>
  </li>
  <li>Small Code Footprint
    <ul>
      <li>The code used for this is very small.</li>
    </ul>
  </li>
  <li>Used in:
    <ul>
      <li>Facebook Messenger for iOS and Android</li>
      <li>PubNub</li>
    </ul>
  </li>
</ul>

<h2 id="mqtt-ports">MQTT Ports</h2>
<ul>
  <li>Protocol: TCP/IP</li>
  <li>Ports:
    <ul>
      <li>1883 - non-encrypted communication</li>
      <li>8883 - encrypted communication</li>
    </ul>
  </li>
</ul>

<h2 id="maximum-payload-size">Maximum Payload Size</h2>
<ul>
  <li>MQTT Protocol Max Payload - 256 MBs</li>
  <li>AWS IoT MQTT Max Payload - 128 KBs</li>
</ul>

<h2 id="quality-of-service">Quality of Service</h2>
<ul>
  <li>
    <p>Levels:<br />
    <strong><em><u>0 = At Most Once</u></em></strong> (Best effort, No Ack)<br />
      - Sender does not store messages, neither the receiver sends any acknowledgement.<br />
      - This method requires only one message and once the message is sent to the broker by the client it is deleted from the message queue.<br />
      - Therefore QoS 0 nullifies the chances of duplicate messages, which is why it is also known as the <em><u>fire and forget</u></em> method.<br />
      - It provides a minimal and most <em><u>unreliable</u></em> message transmission level that offers the <em><u>fastest delivery effort</u></em>.<br />
      - <img src="/assets/images/mqtt/mqtt-qos-0.png" alt="mqtt-qos-0" /></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 = *&lt;u&gt;At Least Once&lt;/u&gt;* (Acknowledged, Retransmitted if Ack not received)\
  - Using QoS 1, the delivery of a message is guaranteed (at least once, but the *&lt;u&gt;message may be sent more than once&lt;/u&gt;* , if necessary).
  - This method needs two messages.
  - Here, the sender sends a message and waits to receive an acknowledgment (*&lt;u&gt;PUBACK&lt;/u&gt;* message).
  - If it receives an acknowledgment from the client then it deletes the message from the outward-bound queue.
  - In case, it does not receive a PUBACK message, it resends the message with the *&lt;u&gt;duplicate flag (DUP flag) enabled&lt;/u&gt;*.
  - ![mqtt-qos-1](/assets/images/mqtt/mqtt-qos-1.png)

2 = *&lt;u&gt;Exactly Once&lt;/u&gt;*\
  - The QoS 2 level setting guarantees exactly-once delivery of a message.
  - This is the *&lt;u&gt;slowest&lt;/u&gt;* of all the levels and needs four messages.
  - In this level, the *&lt;u&gt;sender&lt;/u&gt;* sends a message (*&lt;u&gt;PUBLISH&lt;/u&gt;*) and waits for an *&lt;u&gt;acknowledgment&lt;/u&gt;* (*&lt;u&gt;PUBREC&lt;/u&gt;* message).
  - The *&lt;u&gt;receiver&lt;/u&gt;* also sends a PUBREC message.
  - If the *&lt;u&gt;sender&lt;/u&gt;* of the message fails to receive an acknowledgment (PUBREC), it sends the message again with the *&lt;u&gt;DUP flag enabled&lt;/u&gt;*.
  - Upon receiving the acknowledgment message PUBREC, the *&lt;u&gt;sender&lt;/u&gt;* transmits the *&lt;u&gt;message release message&lt;/u&gt;* (*&lt;u&gt;PUBREL&lt;/u&gt;*).
  - If the *&lt;u&gt;receiver&lt;/u&gt;* does not receive the PUBREL message it resends the PUBREC message.
  - Once the *&lt;u&gt;receiver&lt;/u&gt;* receives the PUBREL message, It forwards the message to all the subscribing clients.
  - Note: *&lt;u&gt;For Sender Broker is the receiver and for Receiver Broker is the sender&lt;/u&gt;*.
  - Thereafter the *&lt;u&gt;receiver&lt;/u&gt;* sends *&lt;u&gt;a publish complete&lt;/u&gt;* (*&lt;u&gt;PUBCOMP&lt;/u&gt;*) message.
  - In case the *&lt;u&gt;sender&lt;/u&gt;* does not receive the PUBCOMP message, it resends the PUBREL message.
  - Once the sending client receives the PUBCOMP message, the transmission process is marked as completed and the message can be deleted from the outbound queue.   - ![mqtt-qos-2](/assets/images/mqtt/mqtt-qos-2.png)
</code></pre></div>    </div>
  </li>
  <li>
    <p>these messages are same as used in WiFi communication.</p>
  </li>
</ul>

<h2 id="retained-messages">Retained Messages</h2>
<ul>
  <li>Server keeps messages even after sending it to all Subscribers.</li>
  <li>New Subscribers get the retained messages.
    <ul>
      <li>We had seen this behavior in PubNub, where last message Published to Channel was retained till the next message is Published to that channel.</li>
      <li>This Last message was available to new subscriber.</li>
      <li><em><u>Only One Message</u></em> is retained per Topic.</li>
      <li>Usecase:
        <ul>
          <li>Sensor periodically sending a message on a topic. New subscriber will get the last state of the sensor with Retained message.</li>
        </ul>
      </li>
      <li>Reference: <a href="/assets/docs/mqtt/MQTT_Retained_Messages_Explained.pdf">MQTT Retained Messages Explained</a></li>
    </ul>
  </li>
</ul>

<h2 id="clean-session-and-durable-session">Clean Session and Durable Session</h2>
<ul>
  <li><em><u>Clean Session</u></em>:
    <ul>
      <li>Clean Session Flag = 1	[Optional]</li>
      <li>All of the client’s subscriptions are removed when it disconnects from the server.</li>
    </ul>
  </li>
  <li><em><u>Durable Session</u></em>:
    <ul>
      <li>Clean Session Flag = 0	[Optional]</li>
      <li>The client’s subscriptions remain in effect after any disconnection.</li>
      <li>In this event, subsequent messages that arrive carrying a High QoS designation are stored for delivery after the connection is reestablished.</li>
    </ul>
  </li>
</ul>

<h2 id="retained-messages-clean-session-and-qos-inter-related-behavior">Retained messages, Clean Session and QoS inter-related behavior</h2>
<p><img src="/assets/images/mqtt/RetainedMessages_CleanSession_QoS.png" alt="Retained messages, Clean Session and QoS inter-related behavior" />
  Reference: <a href="http://www.steves-internet-guide.com/mqtt-retained-messages-example/">MQTT Retained Messages Explained</a></p>

<h2 id="wills">Wills</h2>
<ul>
  <li>A Will or a Message is informed by client with server that should be published to a specific Topic or Topics in the event of an unexpected disconnection.</li>
  <li>A Will is an alarm or security settings where system when a remote sensor has lost contact with the network.</li>
</ul>

<h2 id="keep-alive-messages">Keep Alive Messages</h2>
<ul>
  <li>Periodically sent</li>
</ul>

<h2 id="topic-trees-strings">Topic Trees, Strings</h2>
<ul>
  <li>Topics are organized Hierarchically into Topic Trees, using the ‘/’ character to create subtopics in the Topic String.</li>
  <li><em><u>Topic String</u></em>
    <ul>
      <li>A character string that identifies the Topic of a publish/subscribe message.</li>
      <li>Topic strings can contain either of two Wildcards:</li>
      <li>These <strong><em><u>WildCards</u></em></strong> Allows subscribers to match patterns within strings defined by message publishers</li>
      <li>Wildcard: <code class="language-plaintext highlighter-rouge">#</code>:
        <ul>
          <li>Multilevel</li>
          <li>used to match any number of levels within a Topic.
            <ul>
              <li>e.g. subscribers to <code class="language-plaintext highlighter-rouge">truck/contents/#</code> receive all messages that are designated for the topics:</li>
              <li><code class="language-plaintext highlighter-rouge">truck/contents</code></li>
              <li><code class="language-plaintext highlighter-rouge">truck/contents/rfid</code></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Wildcard: <code class="language-plaintext highlighter-rouge">+</code>:
        <ul>
          <li>Single Level</li>
          <li>used to match Just ONE Topic Level.
            <ul>
              <li>e.g. <code class="language-plaintext highlighter-rouge">truck/+</code> <u>matches</u> <code class="language-plaintext highlighter-rouge">truck/contents</code> <em><u>but not</u></em> <code class="language-plaintext highlighter-rouge">truck/contents/rfid</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="mqtt-brokers-comparison">MQTT Brokers Comparison</h2>
<ul>
  <li><a href="/assets/docs/mqtt/Stress-Testing-MQTT-Brokers.pdf">Stress-Testing MQTT Brokers: A Comparative Analysis of Performance Measurements:</a>
    <ul>
      <li>Tested Borkers:
        <ul>
          <li><a href="https://mosquitto.org/"><em><u>Mosquitto</u></em></a> - <a href="https://www.bevywise.com/mqtt-broker/"><em><u>Bevywise MQTT Route</u></em></a> - <a href="https://activemq.apache.org/"><em><u>ActiveMQ</u></em></a> - <a href="https://www.hivemq.com/"><em><u>HiveMQ CE</u></em></a> - <a href="https://vernemq.com/"><em><u>VerneMQ</u></em></a> - <a href="https://www.emqx.io/"><em><u>EMQ X</u></em></a></li>
        </ul>
      </li>
      <li><strong><em><u>Mosquitto</u></em></strong> outperforms the other considered solutions in most metrics;</li>
      <li><strong><em><u>ActiveMQ</u></em></strong> is the best performing one in terms of <em><u>Scalability</u></em> due to its multi-threaded implementation.</li>
      <li><strong><em><u>Bevywise MQTT Route</u></em></strong> has promising results for <em><u>resource-constrained</u></em> scenarios.</li>
      <li><strong><em><u>ActiveMQ</u></em></strong> scales well in distributed/multi-core environment to beat all other brokers’ performance.</li>
      <li>If the hardware is <em><u>resource-constrained</u></em> (CPU/Memory/IO/Performance), then <strong><em><u>Mosquitto</u></em></strong> or <strong><em><u>Bevywise MQTT Route</u></em></strong> can be taken as better choices.</li>
    </ul>
  </li>
</ul>

<h2 id="running-mqtt-broker-in-containerized-mode">Running MQTT broker in Containerized mode</h2>
<ul>
  <li><a href="https://hub.docker.com/_/eclipse-mosquitto?tab=description">eclipse-mosquitto</a>
    <ul>
      <li>Maintained by: the Eclipse Foundation</li>
      <li>Supported architectures: (more info) amd64, arm32v6, arm64v8, i386, ppc64le, s390x</li>
    </ul>
  </li>
</ul>

:ET